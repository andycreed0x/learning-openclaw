# Session 3: Channels & Multi-Platform - Narration Script

**Estimated duration:** ~5 minutes
**Tone:** Practical, hands-on, showing the breadth of platform support
**Pace:** Moderate, slightly quicker through the platform list, slower on configuration details

---

## [0:00] Opening

Welcome to Session 3 of Learning OpenClaw! Today is all about channels -- the connectors that let OpenClaw talk to the outside world. By the end of this session, you will understand how channels work, how to configure them, how to control access with DM policies, and how messages get routed to the right agent.

The tagline for this session is: one assistant, every platform. Let's see how that works.

---

## [0:25] What Are Channels?

So what exactly is a channel?

A channel is a messaging platform connector. Its job is to translate platform-specific messages -- things like WhatsApp messages, Telegram updates, or Discord events -- into OpenClaw's internal, unified format.

Each channel handles one platform connection. It normalizes incoming messages so the rest of the system does not have to care about platform differences. It manages authentication with external APIs -- things like bot tokens and API keys. And it handles platform-specific features like reactions, threads, and buttons.

Think of channels as translators. They speak the language of each platform on one side, and OpenClaw's universal language on the other.

---

## [1:00] 13+ Supported Platforms

And OpenClaw speaks a *lot* of languages. There are over 13 supported platforms out of the box.

**WhatsApp** -- using the Baileys library. Stable and fully featured.

> **Pronunciation note:** Baileys is pronounced "BAY-lees."

**Telegram** -- using the Grammy library. Rock solid.

> **Pronunciation note:** Grammy is "GRAM-ee" -- like the music award.

**Discord** -- using discord.js. Stable.

**Slack** -- using the Bolt framework. Stable.

**Web Chat** -- built right into OpenClaw. No external dependencies at all.

**Matrix** -- using the matrix-js-sdk. Stable. Great for privacy-focused setups.

**Signal** -- using signal-cli. Currently in beta but functional.

**IRC** -- using irc-framework. Stable. Old school but reliable.

> **Pronunciation note:** XMPP is spelled out: "X-M-P-P."

**XMPP** -- using stanza.io. Stable.

**Nostr** -- using nostr-tools. In beta.

> **Pronunciation note:** Nostr is "NOSS-ter" -- it is a decentralized social protocol.

**SMS** -- via Twilio. Stable.

**LINE** -- using the LINE SDK. Stable.

And finally, **Custom** -- a webhook-based channel that lets you integrate with anything that can send HTTP requests.

That is an impressive lineup, and more channels are being added regularly.

---

## [2:05] Channel Architecture

Here is how the architecture looks. On one side, you have user devices: someone on their phone using WhatsApp, another person on Telegram, someone in Discord, and someone on a web browser.

Each device connects to its respective channel running on a Node. The WhatsApp channel, the Telegram channel, the Discord channel, and the Web channel. All of these channels feed into a single Router inside the Gateway.

The key insight here is that each channel runs independently. If your WhatsApp channel goes down, Telegram and Discord keep working. There is no single point of failure at the channel level.

---

## [2:35] Channel Configuration Example

Configuring a channel is straightforward. It goes in your node's JSON5 config file.

Each channel gets a unique name -- like "my-telegram" or "my-discord." You specify the type, which tells OpenClaw which platform connector to use. Then you add platform-specific settings like bot tokens. And you set a DM policy, which controls who can message the bot.

Here is a quick example: a Telegram channel with a bot token pulled from an environment variable and pairing mode for DM access. A Discord channel with allowlist mode. And a web channel running on port 3100 with open access.

Notice how secrets are referenced with the dollar-sign prefix -- `$TELEGRAM_BOT_TOKEN`, `$DISCORD_BOT_TOKEN`. Never hardcode tokens in your config file.

---

## [3:10] DM Policies

DM policies are a key security feature. They control who can message your assistant in private, direct messages.

There are four options.

**Pairing** -- the user must enter a verification code to start chatting. The code is generated by OpenClaw and you share it with the people you want to have access. This is the recommended default for personal use. Simple UX, strong security.

**Allowlist** -- only pre-approved user IDs can send DMs. You specify the platform-specific user IDs in your config. Best for teams and organizations where you know every user.

**Open** -- anyone can message the bot. No restrictions. Only use this for public-facing bots or demos. Be careful with this one.

**Disabled** -- no DMs allowed at all. The bot only responds in group chats. Useful for group-only support bots.

My recommendation? Start with pairing mode. It gives you strong security with minimal friction.

---

## [3:55] Multi-Agent Routing

So when a message arrives, how does OpenClaw decide which agent handles it?

It uses a priority chain with three levels.

**Priority 1: Exact Match.** The system checks if there is a direct mapping for that specific channel and user -- or channel and group. If yes, that specific agent handles it.

**Priority 2: Channel Default.** If there is no exact match, the system uses the default agent configured for that channel.

**Priority 3: Global Default.** If the channel has no default either, the system falls back to the global default agent.

This lets you have different agents for different contexts without complex configuration. For example, a coding-focused agent for your Discord developer channel, and a general-purpose assistant for everything else.

---

## [4:25] Group Chat Support

OpenClaw also supports group chats, and this works slightly differently depending on the platform.

The bot joins as a group member and can be activated in three ways.

**Mention mode** -- the bot only responds when someone @mentions it by name. This is the most common and least intrusive option.

**Keyword mode** -- the bot responds when it detects configured trigger words like "help" or "question." Great for support bots.

**Always mode** -- the bot responds to every message in the group. Use this sparingly, as it can get noisy.

Group context is shared across members, so the bot is aware of the full conversation happening in the group.

---

## [4:50] Media Support

Not all platforms support the same features, and OpenClaw handles this gracefully.

WhatsApp, Telegram, Discord, and Slack have full support for images, audio, files, buttons, and reactions.

The Web Chat supports images, files, and buttons, with partial audio support and no reactions yet.

IRC, being text-only, does not support any media features.

SMS supports images via MMS but nothing else.

The important thing is that your agent code does not need to worry about these differences. If an agent tries to send a button to IRC, OpenClaw will gracefully fall back to a text-based alternative. The abstraction handles it for you.

---

## [5:15] Web Channel

The Web Channel deserves a quick spotlight because it is the easiest way to get started.

It is a built-in web UI that requires zero external accounts. No API keys, no bot registration. Just configure a port number and open your browser. It supports markdown rendering, file uploads, image display, customizable theming, and it is embeddable via iframe if you want to add it to an existing web application.

If you are just getting started with OpenClaw, the Web Channel is your best friend for testing and development.

---

## [5:35] Key Takeaways

Three things to remember from this session.

**Channels abstract platform complexity.** Write your agent logic once and deploy it to 13+ platforms without any changes.

**DM policies control access.** Choose from pairing, allowlist, open, or disabled to match your security needs.

**Routing determines which agent responds.** The priority chain -- exact match, then channel default, then global default -- lets you direct messages to the right agent automatically.

---

## [5:55] Closing / Resources

Check out the channel configuration docs for detailed setup guides for each platform, the routing documentation for advanced routing rules, and the DM policy reference for all the options.

Next up in Session 4, we dive into agents themselves -- how to create AI personalities, how the memory system works, and how sessions manage conversation lifecycles. That is where the real magic happens. See you there!
