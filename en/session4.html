<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Agents, Memory & Sessions - Learning OpenClaw</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/dist/reset.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/dist/reveal.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/dist/theme/black.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/plugin/highlight/monokai.css">
  <link rel="stylesheet" href="../assets/custom.css">
</head>
<body>
  <div class="reveal">
    <div class="slides">

      <!-- Slide 1: Title -->
      <section>
        <span class="session-badge">Session 4 of 6</span>
        <h1>Agents, Memory & Sessions</h1>
        <p>Building AI personalities that remember</p>
        <p class="small">Isolated agents with persistent context</p>
        <aside class="notes">
          Welcome to Session 4. This is where OpenClaw gets truly powerful. We'll cover
          how to create agents with distinct personalities, how the memory system works
          to give your assistant continuity across conversations, and how sessions manage
          the lifecycle of each interaction.
        </aside>
      </section>

      <!-- Slide 2: What is an Agent? -->
      <section>
        <h2>What is an Agent?</h2>
        <div class="highlight-box info">
          <strong>Agent</strong> = an AI personality with its own workspace, tools, and memory.
          Each agent is <span class="cyan">fully isolated</span> from others.
        </div>
        <ul>
          <li class="fragment">Has its own <span class="yellow">system prompt</span> and behavior rules</li>
          <li class="fragment">Maintains <span class="green">separate memory</span> per user</li>
          <li class="fragment">Can access different <span class="purple">tools and skills</span></li>
          <li class="fragment">Runs in a <span class="cyan">sandboxed environment</span></li>
        </ul>
        <div class="highlight-box warning fragment">
          <strong>Key concept:</strong> Agents don't share memory or context.
          What one agent knows, another does not.
        </div>
        <aside class="notes">
          Think of agents as separate employees, each with their own desk,
          files, and expertise. An assistant agent doesn't know what the
          developer agent is working on, and vice versa. This isolation is
          intentional: it keeps concerns separated and prevents data leakage.
        </aside>
      </section>

      <!-- Slide 3: Agent Workspace Structure -->
      <section>
        <h2>Agent Workspace Structure</h2>
        <pre class="ascii-art">
workspace/
â”œâ”€â”€ agents/
â”‚   â””â”€â”€ my-agent/
â”‚       â”œâ”€â”€ AGENTS.md    &larr; Agent behavior &amp; rules
â”‚       â”œâ”€â”€ SOUL.md      &larr; Personality &amp; tone
â”‚       â”œâ”€â”€ TOOLS.md     &larr; Available tools config
â”‚       â”œâ”€â”€ USER.md      &larr; Per-user context
â”‚       â””â”€â”€ MEMORY.md    &larr; Long-term memory
â”œâ”€â”€ skills/              &larr; Custom skills
â””â”€â”€ sandbox/             &larr; Sandboxed execution
        </pre>
        <div class="highlight-box success fragment">
          <strong>Everything is files.</strong> Agent configuration is just markdown files
          in a directory. Edit them with any text editor.
        </div>
        <aside class="notes">
          The workspace is the heart of OpenClaw's agent system. Each agent lives
          in its own subdirectory under agents/. All configuration is done through
          markdown files, which makes it easy to version control, review, and
          collaborate on agent behavior. No databases, no admin panels for this.
        </aside>
      </section>

      <!-- Slide 4: Personality Files Explained -->
      <section>
        <h2>Personality Files Explained</h2>
        <div class="columns">
          <div class="col">
            <div class="highlight-box info fragment">
              <strong>AGENTS.md</strong><br>
              System prompt, behavior rules, response style.
              The core instructions for the agent.
            </div>
            <div class="highlight-box success fragment">
              <strong>SOUL.md</strong><br>
              Personality traits, tone, language preferences.
              Makes the agent feel unique and consistent.
            </div>
          </div>
          <div class="col">
            <div class="highlight-box warning fragment">
              <strong>TOOLS.md</strong><br>
              Which tools the agent can use and how.
              Controls capabilities and permissions.
            </div>
            <div class="highlight-box fragment">
              <strong>USER.md</strong><br>
              Per-user context, auto-generated.
              Stores preferences and past interactions.
            </div>
          </div>
        </div>
        <div class="fragment">
          <p class="medium"><span class="cyan">MEMORY.md</span> &mdash; Long-term memory, persists across all sessions (covered in detail later).</p>
        </div>
        <aside class="notes">
          Let's break down each file. AGENTS.md is the main system prompt: it
          tells the LLM who it is and how to behave. SOUL.md adds personality
          flavor: is the agent formal or casual? Funny or serious? TOOLS.md
          controls what actions the agent can take. USER.md is created
          automatically for each user and stores context about them.
        </aside>
      </section>

      <!-- Slide 5: Multi-Agent Setup -->
      <section>
        <h2>Multi-Agent Setup</h2>
        <div class="mermaid">
graph TB
    GW[Gateway]
    GW --> A1["ðŸ¤– Assistant<br/>General Purpose"]
    GW --> A2["ðŸ’» Developer<br/>Code &amp; DevOps"]
    GW --> A3["ðŸ“Š Analyst<br/>Data &amp; Reports"]
    A1 --> W1[workspace/agents/assistant/]
    A2 --> W2[workspace/agents/developer/]
    A3 --> W3[workspace/agents/analyst/]
        </div>
        <ul class="small fragment">
          <li>Each agent has its own <span class="yellow">workspace directory</span></li>
          <li>Route messages to agents via <span class="cyan">channel config</span> or <span class="green">routing rules</span></li>
          <li>Agents can have different <span class="purple">LLM providers</span> and models</li>
        </ul>
        <aside class="notes">
          A typical setup might have a general-purpose assistant for everyday
          questions, a developer agent with code tools enabled, and an analyst
          agent with data access. Each lives in its own workspace directory.
          You can even assign different LLM models to each agent: maybe a
          cheaper model for the assistant and a more capable one for the developer.
        </aside>
      </section>

      <!-- Slide 6: Memory System -->
      <section>
        <h2>Memory System</h2>
        <p>Two types of memory keep your agent context-aware:</p>
        <div class="columns">
          <div class="col">
            <div class="highlight-box info fragment">
              <strong>Daily Notes</strong>
              <ul>
                <li>Short-term memory</li>
                <li>Auto-generated per conversation</li>
                <li>Captures key facts and decisions</li>
                <li>Organized by date</li>
                <li>Input for long-term compaction</li>
              </ul>
            </div>
          </div>
          <div class="col">
            <div class="highlight-box success fragment">
              <strong>MEMORY.md</strong>
              <ul>
                <li>Long-term memory</li>
                <li>Persistent across all sessions</li>
                <li>Compacted from daily notes</li>
                <li>Contains user preferences, important facts</li>
                <li>Loaded into every new session</li>
              </ul>
            </div>
          </div>
        </div>
        <aside class="notes">
          The memory system is what makes OpenClaw's agents feel like they truly
          know you over time. Daily notes are the raw material: after each
          conversation, key information is extracted and saved. MEMORY.md is
          the distilled, long-term memory that gets loaded into every new session.
        </aside>
      </section>

      <!-- Slide 7: Memory Flow -->
      <section>
        <h2>Memory Flow</h2>
        <div class="mermaid">
graph LR
    CONV[Conversation] --> DN["Daily Notes<br/>Auto-saved"]
    DN --> COMP[Compaction]
    COMP --> MEM["MEMORY.md<br/>Long-term"]
    MEM --> NEXT["Next Session<br/>Context"]
        </div>
        <div class="fragment">
          <h3>How Compaction Works</h3>
          <ul class="medium">
            <li>Daily notes accumulate over time</li>
            <li>Compaction process extracts <span class="yellow">important facts</span></li>
            <li>Removes redundant or outdated information</li>
            <li>Updates <span class="cyan">MEMORY.md</span> with distilled knowledge</li>
          </ul>
        </div>
        <div class="highlight-box warning fragment">
          <strong>Result:</strong> Your agent remembers that you prefer dark mode,
          that your cat's name is Luna, and that you're working on a Python project &mdash;
          without re-reading every past conversation.
        </div>
        <aside class="notes">
          The flow is: conversation happens, daily notes capture the highlights,
          compaction distills them into MEMORY.md. Next time a session starts,
          MEMORY.md is loaded as context. This means the agent starts every
          conversation already knowing the important things about you. The
          compaction step is crucial: it prevents memory from growing unbounded.
        </aside>
      </section>

      <!-- Slide 8: Sessions Explained -->
      <section>
        <h2>Sessions Explained</h2>
        <div class="highlight-box info">
          <strong>Session</strong> = one conversation thread between a user and an agent.
        </div>
        <ul>
          <li class="fragment"><span class="cyan">Created</span> when a user sends a new message</li>
          <li class="fragment"><span class="green">Active</span> while the conversation is ongoing</li>
          <li class="fragment"><span class="yellow">Idle</span> when there's no activity for a configured period</li>
          <li class="fragment"><span class="red">Expired</span> after the idle timeout is reached</li>
        </ul>
        <div class="highlight-box success fragment">
          <strong>Why sessions matter:</strong> They manage conversation context,
          control memory usage, and enable history compaction when conversations get too long.
        </div>
        <aside class="notes">
          Sessions are the container for conversations. They track the message
          history, manage the context window, and determine when to compact
          history. Without session management, long conversations would exceed
          the LLM's context limit and either fail or lose important context.
        </aside>
      </section>

      <!-- Slide 9: Session State Diagram -->
      <section>
        <h2>Session Lifecycle</h2>
        <div class="mermaid">
stateDiagram-v2
    [*] --> Created: New message
    Created --> Active: Processing
    Active --> Idle: No activity
    Idle --> Active: New message
    Idle --> Expired: Timeout
    Expired --> [*]: Cleanup
    Active --> Compacted: History too long
    Compacted --> Active: Continue
        </div>
        <p class="small fragment">Sessions automatically manage their own lifecycle &mdash; no manual cleanup needed.</p>
        <aside class="notes">
          The state diagram shows how sessions transition. The key transitions to
          understand: Active to Compacted happens when the conversation history
          exceeds the configured maximum. During compaction, older messages are
          summarized and replaced with a condensed version. Idle to Expired
          happens after the configured timeout, at which point daily notes are
          generated and the session is cleaned up.
        </aside>
      </section>

      <!-- Slide 10: Session Configuration -->
      <section>
        <h2>Session Configuration</h2>
        <pre><code class="language-json5" data-trim>
{
  sessions: {
    // Time before an idle session expires
    idleTimeout: "30m",

    // Maximum messages before compaction triggers
    maxHistory: 50,

    // How to summarize old messages
    compaction: {
      strategy: "summarize",
      keepRecent: 10,
      summaryModel: "fast"
    },

    // Daily notes generation
    dailyNotes: {
      enabled: true,
      extractFacts: true
    }
  }
}
        </code></pre>
        <div class="highlight-box info fragment">
          <strong>Tip:</strong> Lower <code>maxHistory</code> saves tokens but may lose context.
          Start with <span class="yellow">50</span> and adjust based on your usage.
        </div>
        <aside class="notes">
          Here's a typical session configuration. idleTimeout controls how long
          a session stays alive without messages. maxHistory determines when
          compaction kicks in. The compaction strategy "summarize" uses the LLM
          to create a summary of older messages while keepRecent preserves the
          last N messages verbatim. dailyNotes controls whether the system
          automatically extracts facts after each session.
        </aside>
      </section>

      <!-- Slide 11: Key Takeaways -->
      <section>
        <h2>Key Takeaways</h2>
        <div class="highlight-box success fragment">
          <strong>1. Agents are isolated AI personalities</strong><br>
          Each agent has its own workspace, tools, and memory. They don't share context.
        </div>
        <div class="highlight-box info fragment">
          <strong>2. Memory persists across sessions</strong><br>
          Daily notes capture short-term context. MEMORY.md provides long-term continuity.
        </div>
        <div class="highlight-box warning fragment">
          <strong>3. Sessions have lifecycle management</strong><br>
          Automatic compaction, idle timeouts, and cleanup keep everything running smoothly.
        </div>
        <aside class="notes">
          Three things to remember: agents are isolated by design, which is a
          feature not a limitation. Memory gives your agent continuity across
          sessions, so it genuinely learns about you over time. And session
          management handles the complexity of long conversations automatically.
          Next session, we'll cover tools and skills, which give your agents
          the ability to take action in the real world.
        </aside>
      </section>

      <!-- Slide 12: Resources -->
      <section>
        <h2>Resources</h2>
        <ul>
          <li><a href="https://openclaw.com/docs/agents">Agent Configuration Docs</a></li>
          <li><a href="https://openclaw.com/docs/agents/multi-agent">Multi-Agent Setup Guide</a></li>
          <li><a href="https://openclaw.com/docs/memory">Memory System Docs</a></li>
          <li><a href="https://openclaw.com/docs/sessions">Session Management Reference</a></li>
          <li><a href="https://openclaw.com/docs/agents/personality">Personality Files Guide</a></li>
          <li><a href="https://openclaw.com/docs/memory/compaction">Compaction Strategies</a></li>
        </ul>
        <div class="highlight-box info">
          <strong>Next session:</strong> Tools & Skills &mdash; extending your agents with
          real-world capabilities.
        </div>
        <aside class="notes">
          Here are the relevant documentation links for further reading.
          Session 5 covers tools and skills, where we'll see how to give
          your agents the ability to run code, call APIs, manage files,
          and more. That's where OpenClaw really becomes a powerful
          personal automation platform.
        </aside>
      </section>

    </div>
  </div>
  <div class="nav-footer">
    <a href="index.html">&larr; Table of Contents</a> &middot; Session 4 of 6
  </div>
  <script src="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/dist/reveal.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/plugin/highlight/highlight.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/plugin/notes/notes.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/plugin/zoom/zoom.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.min.js"></script>
  <script>
    mermaid.initialize({ startOnLoad: false, theme: 'dark' });
    Reveal.initialize({
      hash: true,
      slideNumber: true,
      width: 1280,
      height: 720,
      margin: 0.04,
      minScale: 0.2,
      maxScale: 2.0,
      plugins: [RevealHighlight, RevealNotes, RevealZoom],
    }).then(() => {
      mermaid.run({ querySelector: '.mermaid' });
      Reveal.on('slidechanged', () => { mermaid.run({ querySelector: '.mermaid' }); });
    });
  </script>
</body>
</html>
